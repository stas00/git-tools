# -*- mode: sh;-*-
###########
### git ###
###########

# docs:

# good learning git resources
https://learngitbranching.js.org/ - visual teaching with exercises

# tools
https://github.com/tj/git-extras/tree/master/bin


# terminology
origin = remote repository URL with short name origin


### download a sub-directory from a git tree ###
# e.g. https://github.com/buckyroberts/Source-Code-from-Tutorials/tree/master/Python
#1. replace tree/master => trunk
#2. svn co the new url
svn co https://github.com/buckyroberts/Source-Code-from-Tutorials/trunk/Python

### clone ###

# clone a private repo
git clone https://stas00@github.com:/stas00/fastai-transcript/

# clone a specific branch w/o fetching any other branches
git clone --single-branch --branch megatron-deepspeed https://huggingface.co/bigscience/gpt2-350m-en

# clone a specific branch after fetching all branches
git clone --branch megatron-deepspeed https://huggingface.co/bigscience/gpt2-350m-en




### add ###

git add [folder/file]

# undo add (before push was made)
git reset [folder/file]



### remove ###

git rm [folder/file]

# remove remote file copy only. e.g. remove database.yml that is already checked
# in but leaving the local copy untouched. This is also handy for removing
# ignored files that are already pushed without removing the local copies.
git rm --cached database.yml
# for a directory:
git rm --cached -r mydirectory


### status ###

git status

# brief status
git status -s

# brief status excluding untracked files
git status -s -uno

# get the status of the local repository compared to remote
git remote show origin

# current SHA revision
git rev-parse --short HEAD

# show only untracked files, including sub-dirs if they haven't been added yet
git ls-files --others --exclude-standard
# same but has a lot of extra noise - can't feed it into a pipe
git status -u

# show only modified files
git ls-files --modified


# current SHA / commit ID, long and short
git show -s --format=%H
git show -s --format=%h





###  push ###

git push


# dry-run (do everything except for the actually sending of the data)
# but it doesn't show anything useful - see commands below for visual hints of what will happen
git push --dry-run

# show which files have changed and view the diff compared to the remote master branch HEAD
git diff --stat --patch origin master

# list of files to be pushed
git diff --stat --cached [remote/branch]

# show code diff of the files to be pushed
git diff [remote repo/branch]

# show full file paths of the files that will change
git diff --numstat [remote repo/branch]

# if the files got staged via merge, then diff against the branch itself,
git diff origin/my-branch-name
# or simpler:
git diff origin/master
# with status:
git diff --name-status origin/master




### commit ###

git commit -a
# -a is crucial as w/o it you need to 'git add' every file that has changed!

# amend (re-edit) the already committed (but not pushed file)
git commit --amend -m "Initial Commit"

# to push an empty commit - e.g. to force a CI rebuild - when there is no diff to push
git commit --allow-empty -m "Trigger CI"
git push

# commit with a different author tagged (contributor)
git commit --author "Manuel R. Ciosici <manuelrciosici@gmail.com>" -am "corrections"

### authentication ###

# cache auth
git config --global credential.helper cache

# adjust caching time
git config --global credential.helper 'cache --timeout=36000'

# can also save the password in clear if the system is safe
# this is also needed for huggingface_hub auth caching to work
git config --global credential.helper store

# to reset! e.g. when getting:
# remote: Forbidden
# fatal: unable to access 'https://huggingface.co/hf-internal-testing/tiny-layoutlm/': The requested URL returned error: 403
git config --global --unset credential.helper



### config ###

# delete/remove config entry from local repo
git config --unset user.email

# delete/remove config entry globally
git config --global --unset user.email

### update ###

git pull

# git pull is shorthand for
git fetch
git merge FETCH_HEAD

# git with sub-modules
git clone --recursive https://github.com/pytorch/pytorch
cd pytorch
#
# if you are updating an existing checkout
git submodule sync
git submodule update --init --recursive

# display the incoming/outgoing changes before pull/push

git log ^master origin/master
git log master ^origin/master

### rename multiple files


# find all files matching foo*.py and git rename s/foo/bar/ (this avoids destroying anything under .git)
# 1. rename.pl way - note that the history isn't lost if files are first deleted and then added
# `git mv` is the same as `git rm` followed by `git add`
rename.pl 's|OLD|NEW|'
git ls-files -z --deleted | xargs -0 git rm  # this removes missing files as a result of rename
git add new-renamed-files
#
# 2. slightly harder way, but one command
find . -type d -name ".git" -prune -o -type f -name "foo*.py" -exec bash -c 'file={}; git mv $file ${file/foo/bar}' \;

### search/replace

# How to safely and efficiently search/replace files in a git repo using CLI
# must not touch anything under .git/
find . -type d -name ".git" -prune -o -type f -exec perl -pi -e 's|OLDSTR|NEWSTR|g' {} \;
# but it touch(1)es all files which slows down git-side
# so we want to do it on files that actually contain the old pattern
grep --exclude-dir=.git -lIr "OLDSTR" . | xargs -n1 perl -pi -e 's|OLDSTR|NEWSTR|g'


# a more efficient version as it only looks inside git files
# after adding to your ~/.bashrc and starting a new bash shell
# usage: git-replace oldstr newstr
#
function git-replace () {
    files=$(git grep -l "$1")
    if [[ ! -z "$files" ]];
    then
        perl -pi -e "s|$1|$2|g" $files
	    git diff --shortstat
    else
        echo "no match for: $1"
        false
    fi
}



### git GUI ###

# git
git gui

# gitk
gitk --all


### contributors ###

# show a list of contributors ordered by number of commits. Similar to the contributors view of GitHub.
git shortlog -sn




### status and information

# short form log of events
git log --oneline

# show a graph of the tree, showing the branch structure of merges
git log --graph --decorate --pretty=oneline --abbrev-commit
# add --all to show all branches

# show all the commits in a branch that are not in HEAD. e.g. show all commits that are in master but not merged into the current feature branch yet.
git log ..master

# prints a complete list of previous operations.
git reflog



### search git history ###

# to find all commits where commit message contains given word, use
git log --grep=word_to_search_for

# to search all of git history for a string
git log -Sword_to_search_for
# this will find any commit that added or removed the string password. Here are a few options:
#
# -p: will show the diffs. If you provide a file (-p file), it will generate a patch for you.
# -G: looks for differences whose added or removed line matches the given regexp, as opposed to
# -S, which "looks for differences that introduce or remove an instance of string".
#  --all: searches over all branches and tags; alternatively, use --branches[=<pattern>] or --tags[=<pattern>]
#
# same via blame if the file is known
git blame filename | less
# search the output for the desired code

# search for a specific path
git log -- foo/bar/file
# search for a partial match in a path
git log -- *foo*


# search and exclude certain paths from the results:
# exclude subfolder foo
git log -- . ":(exclude)foo"
# exclude several subfolders
git log -- . ":(exclude)foo" ":(exclude)bar"
# exclude specific elements in that subfolder
git log -- . ":(exclude)foo/bar/file"
# exclude any given file in that subfolder
git log -- . ":(exclude)foo/*file"
git log -- . ":(exclude,glob)foo/*file"
# make exclude case insensitive
git log -- . ":(exclude,icase)FOO"

# which branch contains a specified sha key
git branch –contains SHA

# find the last commit of a given branch
git log -n 1 origin/branch-name
# to get this information for all tags/branches
git ls-remote git://github.com/<user>/<project>.git

###############
### merging ###
###############

# merge branch_b into branch_a
git checkout branch_a
git merge --no-edit branch_b
git push
#
# if branch_b isn't local yet and you get the error:
#   merge: branch_b - not something we can merge
# run the following first and the repeat the above
git checkout branch_b


######################
### cherry picking ###
######################

# choose a commit rev from one branch (e.g. PR) and merge it the current checkout
git show <commit>        # check that this is the right rev
git cherry-pick <commit> # merge it into the current checkout
git push

# to merge a range of commits:
git cherry-pick <commit1>..<commitN>

# cherry picking parts of a commit (only sections/hunks and not whole files)
git cherry-pick -n <commit> # get your patch, but don't commit (-n = --no-commit)
git reset                   # unstage the changes from the cherry-picked commit
git add -p                  # make all your choices (add the changes you do want)
git commit                  # make the commit!
#
# similar to the above 4 commands - interactive picking (-p == --patch)
git checkout -p <commit>
# and if only changes for specific files are wanted:
git checkout -p <commit> -- path/to/file_a path/to/file_b

# cherry-pick another git repo (can use sha1 instead of FETCH_HEAD)
git fetch <remote-git-url> <branch> && git cherry-pick FETCH_HEAD

# abort the started cherry-pick process, which will revert to the previous state
git cherry-pick --abort

# cherry-picking from another repo
git remote add other https://github.com/microsoft/Megatron-DeepSpeed
git fetch other
git cherry-pick <rev>

# cherry-picking github PR requests
# 1. add to .git/config: fetch = +refs/pull/*/head:refs/remotes/origin/pr/*, so that it looks like (last line) - need to do only once per checkout
[remote "origin"]
        url = git@github.com:fastai/git-tools.git
        fetch = +refs/heads/*:refs/remotes/origin/*
        fetch = +refs/pull/*/head:refs/remotes/origin/pr/*
# 2. sync the PRs
git fetch origin
# 3a. cherry pick from the PR
git cherry-pick <rev>
# 4b. or checkout a particular PR
git checkout pr/999
#
# step 1 can be automated with:
#!/usr/bin/env bash
# adds fetch = +refs/pull/*/head:refs/remotes/origin/pr/*
git remote -v | grep fetch | grep github | \
    while read remote url _; do
        if ! git config --get-all "remote.$remote.fetch" | grep -q refs/pull
        then
            git config --add "remote.$remote.fetch" \
                '+refs/pull/*/head:refs/remotes/'"$remote"'/pull/*'
        fi
done

### Merge Git Updates with local changes


### checkouts

# checkout a specific commit
git checkout <sha1>/or-short-hash

### overwrite local changes ###

# If you want to remove all local changes from your working copy, simply stash them:
git stash push --keep-index
# or if it's important you can name it
git stash push "your message here"

# to merge the local changes saved with 'git stash push' after 'git pull'
git stash pop
# (but that seems to not work well for jupyter notebooks)
# if the merge fails, it doesn't get removed from the stash.
# once merge conflict is manually removed, need to manually call:
git stash drop

# to merge a specific stash by the number
git stash apply n
git stash apply stash@{n}

# if there was a conflict from git stash pop (which requires merge):
# 1. edit the conflict file
# 2. git add conflict_file
# git diff --cached is now needed
# or can repeat
# git stash && git stash pop
# and now a normal git diff will work.
#
# also can unstage the stash pop merge with
git reset


# If you don't need them anymore, you now can drop that stash:
git stash drop

# to override all local changes and does not require an identity:
git reset --hard
git pull
# or:
git checkout -t -f remote/branch
git pull
# Discard local changes for a specific file
git checkout dirs-or-files
git pull
# maintain current local commits by creating a branch from master before resetting
git checkout master
git branch new-branch-to-save-current-commits
git fetch --all
git reset --hard origin/master

# pull from upstream and accept all changes blindly
git pull --strategy theirs

# list existing stashes
git stash list

# view stash diff
# latest stash
git stash show -p
# specific stash
git stash show -p stash@{0}
#
# show the contents of each stash with one command
git show $(git stash list | cut -d":" -f 1)



# diff against a specific stash
git diff stash@{0}
# diff against a specific stash's filename
git diff stash@{0} my/file.ipynb
# diff 2 stashes:
git diff stash@{0}..stash@{1}

# XXX: to explore
https://stackoverflow.com/questions/16444720/how-do-i-pop-git-stash-without-triggering-an-auto-merge
git stash branch <branchname> [<stash>]




# check out nbdime - diffing and merging of Jupyter Notebooks
https://nbdime.readthedocs.io/en/stable/ see jupyter.txt for notes


### check out a specific branch ###

git clone https://github.com/vidartf/nbdime -b optimize-diff2


### don't page output --More-- on systems that can't support interactive outputs, like CIs

git --no-pager diff ...


##############
### HF Hub ###
##############

# main doc
https://huggingface.co/docs/hub/repositories-pull-requests-discussions

# to create a PR branch and push into it
1. first go into Community tab
2. click on New pull request - follow the instructions


# to fetch and update a PR branch
git fetch origin refs/pr/1:pr/1
git checkout pr/1
# Do your changes
git add .
git commit -m "Add your change"
git push origin pr/1:refs/pr/1


##############
### GitHub ###
##############

### add collapsible comments (e.g. a huge log file)

<details>
<summary>Full log</summary>
<pre>
log file dump here
</pre>
</details>

### detach / break a fork connection ###

to make a fork into a non-fork on github:
If you want to preserve metadata like issues, project boards, forks, etc. go here: https://support.github.com/contact?tags=rr-forksm and type in “detach fork from parent repo.” It should ask you if you’d like to use the GitHub Virtual Assistant to solve your problem. Accept and the virtual assistant will prompt you for the repo url, and then perform the action for you.


### delete a fork ###

1. Go to github.com/stas00/[FORKED-REPO]/
2. Hit Settings
3. Scroll down and hit [Delete this repository]

# find active forks - when researching if someone made improvements over the original repo
# this one doesn't really show if there are any changes
https://github.com/techgaun/active-forks
https://techgaun.github.io/active-forks/index.html

# find the origin of the given fork
# the last html_url is the one of the fork origin (there are 6 of those in the response)
curl -s https://api.github.com/repos/$fork_user/$repo_name | grep html_url | tail -1

### sync master fork with master repository ###


### Syncing a Fork method ###

https://help.github.com/articles/syncing-a-fork/
# step 1. Configuring a remote for a fork
git clone git://github.com/stas00/fastai sync

cd sync
git remote -v
git remote add origin   git@github.com:stas00/transformers.git
git remote add upstream git@github.com:huggingface/transformers.git
git remote -v

# non-SSH (password auth) version
# git clone https://github.com/stas00/fastai sync
# git remote add upstream https://github.com/fastai/fastai.git

# step 2. Syncing a fork

git fetch upstream
git checkout master
git merge --no-edit upstream/master
git push --set-upstream origin master
# or one line:
git fetch upstream; git checkout master; git merge --no-edit upstream/master; git push --set-upstream origin master

# to update a branch made from that fork:
git checkout branch
git merge origin/master
git push

### XXX: this method I haven't tried yet ###
### Syncing a one person fork method:###

git clone https://github.com/stas00/fastai sync2
cd sync2
git remote set-url origin git@github.com:fastai/fastai
git remote set-url origin --push git@github.com:stas00/fastai



#####################
### pull requests ###
#####################

### fetch a remote PR into your local repo ###

# Method 1: hub
# advantageous as it is set to track the original branch on the fork,
# so that if mor e commits are added, they can be `git pull`ed.
# it uses the same branch name as the original PR
git clone https://github.com/fastai/fastai
cd fastai
hub checkout https://github.com/fastai/fastai/pull/970
# now can check the diff
git diff master



# Method 2: does not commit changes, to see what files are modified and what's changed in them
# from github PR info:
# https://github.com/fastai/fastai/pull/1369
# USERID wants to merge 28 commits into REPONAME:master from USERID:BRANCH
git checkout -b pr-1369
git pull --no-commit https://github.com/USERID/REPONAME.git BRANCH


# Method 3: alias that checks out and switches to pr branch
git pr <id>
# delete all the pull requests created with git pr
git pr-clean #
#
git config --global --add alias.pr '!f() { git fetch -fu ${2:-upstream} refs/pull/$1/head:pr/$1 && git checkout pr/$1; }; f'
#and
git config --global --add alias.pr-clean '!git checkout master ; git for-each-ref refs/heads/pr/* --format="%(refname)" | while read ref ; do branch=${ref#refs/heads/} ; git branch -D $branch ; done'
# but requires that the upsteam is set, e.g.:
git remote add upstream https://github.com/huggingface/transformers.git

# Method 4: git-pr is in the git-extras package
# it switches to a branch with the PR ID
cd git-repo
git-pr PR_ID


# Method 5: (doesn't get updated with new commits to PR)
git fetch origin pull/ID/head:BRANCHNAME
# - ID is the pull request id
# - BRANCHNAME is the name of the new branch that you want to create.
# Next, checkout the newly created branch
git checkout BRANCHNAME

# Method 6: optimized for quickly checking out a PR branch for when it's done often
# in a given project. The first 2 steps only need to be done once per clone.
#
# 1. Locate the section for your github remote in the .git/config file. It looks like this:
[remote "origin"]
	fetch = +refs/heads/*:refs/remotes/origin/*
	url = git@github.com:joyent/node.git
#
# 2. Now add the line fetch = +refs/pull/*/head:refs/remotes/origin/pr/* to this section. Obviously, change the github url to match your project's URL. It ends up looking like this:
[remote "origin"]
	fetch = +refs/heads/*:refs/remotes/origin/*
	url = git@github.com:joyent/node.git
	fetch = +refs/pull/*/head:refs/remotes/origin/pr/*
#
# 3. Now fetch all the pull requests:
$ git fetch origin
From github.com:joyent/node
 * [new ref]         refs/pull/1000/head -> origin/pr/1000
 * [new ref]         refs/pull/1002/head -> origin/pr/1002
 * [new ref]         refs/pull/1004/head -> origin/pr/1004
 * [new ref]         refs/pull/1009/head -> origin/pr/1009
...
#
# 4. To check out a particular pull request:
$ git checkout pr/999
Branch pr/999 set up to track remote branch pr/999 from origin.
Switched to a new branch 'pr/999'


# Method 7: patch-method - requires no checked out repo.
# add .patch to the PR url, download it and apply it to a desired branch:
cd cordova-plugin-media
wget https://github.com/apache/cordova-plugin-media/pull/120.patch
git checkout -b new-branch-pr-210
patch -p1 < 120.patch



#############################
### making a pull request ###
#############################

# example with new branch named: accuracy_np

*** Important - must make a new clone for each new branch ***

# 1. Sync the forked version with master
see above

# 2. clone the main repository fork
# (or if it hasn't been done yet fork it first on github by going to
# github.com:fastai/fastai)
#
# moreover - make sure that the repository fork is up-to-date by syncing it
#
git clone git://github.com/stas00/fastai branch_name
cd branch_name
git remote rm origin
git remote add origin git@github.com:stas00/fastai.git

# 3. create a branch
git checkout -b branch_name

# if the master sync has since updated:
git rebase master

# old:
#git checkout master
#git pull
#git checkout -b branch_name


# 4. edit code and commit changes

# may validate the changes:
jsonlint-php lesson7-cifar10.ipynb

# commit
git commit -a

# 5. push the changes into the branch
git push origin branch_name

# 6. go to github and make pull request
https://github.com/stas00/fastai/tree/branch_name/courses/dl1
and click [Pull Request] on the right upper corner


### update an open PR  ###

# if the upstream master changes impact PR after PR has been submitted we need to rebase


## Method 1

# prep (from within an existing checkout)
# 1. sync my master fork
git fetch upstream; git checkout master; git merge --no-edit upstream/master; git push --set-upstream origin master
#
# 2. get the desired PR
git checkout my-pr-branch # git checkout -
# or checkout the specific PR number
gh pr checkout 6260

# if getting rejected - because previously checked out a different branch but with the same name -
# e.g. with patch-1, force reset:
gh pr checkout 6260 --force
# important: this will overwrite any commits you have locally that aren't present on the remote branch.

# Or pass in a different branch name to checkout the PR to:
gh pr checkout 6260 -b pr-6260

# 3. rebase to my fork
git pull --rebase
git merge origin/master
git push


# Method 2. https://github.com/edx/edx-platform/wiki/How-to-Rebase-a-Pull-Request
#
# it seems to be problematic as it rebases one commit at a time, which can cause multiple collisions
#
# this example is for a fork of https://github.com/huggingface/transformers.git
# setup upstream if it is not there already
# git remote add upstream https://github.com/huggingface/transformers.git
# rebase
git fetch upstream
git rebase upstream/master
# force-push to update your pull request
git config --global push.default simple
git push -f


# Method 3. (incomplete - needs work)
git fetch upstream
git merge --squash upstream/master


### Squash many commits into one before PR

## method A. new branch method

# when working on a complex branch, there will be a lot of commits - since PR
# squashes them anyway, it's the cleanest to squash them all into one commit
# just before doing the PR onto a new branch - and keeping the old branch with
# all the separate commits for later reference. Here is the recipe:

# https://stackoverflow.com/a/32484278/9201239
# If you are on a remote branch (called `feature-branch`) cloned from a Golden Repository (`master`)

# 1. Checkout the golden repo (master)
git checkout master

# 2. Create a new branch from it (golden repo) as follows
git checkout -b dev-branch

# 3. Squash merge with your local branch that you have already
git merge --squash feature-branch

# 4. Commit your changes (this will be the only commit that goes in dev-branch)
git commit -m "My feature complete"

# 5. Push the branch to your local repository
git push origin dev-branch


## method B. interactive way (complex and time consuming)

# https://stackoverflow.com/a/5189600/9201239
# run
git rebase -i <after-this-commit>
# replace "pick" on the second and subsequent commits with "squash" or "fixup",
git commit
git push -f



# <after-this-commit> is either the SHA1 hash or the relative location from the
# HEAD of the current branch from which commits are analyzed for the rebase
# command. For example, if the user wishes to view 5 commits from the current
# HEAD in the past the command is:
git rebase -i HEAD~5.

## method C. soft reset

git reset --soft HEAD~3
git commit
git push -f

# squashes the last three commits into a single new commit in the same way. The
# soft reset just re-points HEAD to the last commit that you do not want to
# squash. Neither the index nor the working tree are touched by the soft reset,
# leaving the index in the desired state for your new commit (i.e. it already
# has all the changes from the commits that you are about to “throw away”).

# this can be added as a global "squash" alias from bash:

git config --global alias.squash '!f(){ git reset --soft HEAD~${1} && git commit --edit -m"$(git log --format=%B --reverse HEAD..HEAD@{1})"; };f'

# Usage:
git squash N

# which automatically squashes together the last N commits, inclusive.
#
# The resultant commit message is a combination of all the squashed commits, in
# order. If you are unhappy with that, you can always git commit --amend to
# modify it manually.

### PR search

# find PR by branch name. e.g. find all the PRs that were originated from branch "patch-1"
 is:pr author:@me  head:patch-1


##################
### GitHub CLI ###
##################

# create PR from the current branch
gh pr create


# dump the status of all the open PRs on github for the current project
gh pr status
gh pr create



################
### branches ###
################

# show local and remote branches
git fetch --all
git branch -a

# get default branch
git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@'
# a much more complicated version that requires repo user + name
curl -s https://api.github.com/repos/${repo_user}/${repo_name} | jq --raw-output .default_branch

# delete branch (after switching out of it, e.g. git checkout master)
git branch -d branch_name
# if it wasn't pushed and no longer needed (careful!)
git branch -D branch_name

# branch delete via github - after the branch has been merged into the master upsteam, can now delete the branch in my fork at github.com
1. https://github.com/stas00/fastai/branches
# or go to https://github.com/stas00/fastai/ (and click [NN branches] above [New pull request] button
2. hit the trash button next to the branch to remove


# List branches that ever merged or not yet merged to current branch.
# It’s a useful check before any merging happens
git branch --merged
git branch --no-merged

# delete branches that have already been merged on master
git branch -r --merged | sed '/develop\|master\|HEAD\|upstream/d' |  sed 's/.*\///' | xargs git push --delete origin
# this doesn't seem to get branches that were created directly on github (usually automatically named as `patch-X`)
#
# another variation (untested)
git fetch -p
git branch -vv | grep ': gone]'|  grep -v "\*" | awk '{ print $1; }' | xargs git branch -d

# switch back to last branch (like 'cd -')
git checkout -
# @{-1} is a way to refer to the last branch you were on. '-' is shorthand for @{-1}
# git branch --track mybranch @{-1}, git merge @{-1}, and git rev-parse --symbolic-full-name @{-1} would work as expected.

# compare two branches in the same repo
git diff --stat --color master..branch_name
# or:
git difftool -d master branch_name
# find the diff from their common ancestor to test, you can use ... instead of ..:
git diff --stat --color master...branch_name
# to compare just specific files
git diff branch1 branch2 -- myfile1.js myfile2.js
# to compare a sub-directory or specific files across different commits
git diff <rev1>..<rev2> -- dir1 file2
# compare rev with one revision before
git diff <rev>~ <rev> -- dir1 file2

# show only names of changed files
git diff --name-only ...

# compare two branches in different repos (e.g. original and github fork)
# given 2 checkouts /path/to/repoA and /path/to/repoB
cd /path/to/repoA
GIT_ALTERNATE_OBJECT_DIRECTORIES=/path/to/repoB/.git/objects git diff $(git --git-dir=/path/to/repoB/.git rev-parse --verify HEAD) HEAD
# another way using GUI with meld (apt install meld)
meld /f1/br/stas00/master/ /f1/br/fastai/master

# find the most recent ancestor between two branches, usually the branching point:
git merge-base master origin/branch_name
# in the case of the currently checked out branch, it's just
git merge-base master HEAD
@
# same, but returns a short rev instead of the long one
git rev-parse --short $(git merge-base master origin/branch_name)
# in the case of the currently checked out branch, it's just
git rev-parse --short $(git merge-base master HEAD)
#
# alternative (doesn't always work, e.g. fails with `git-pr` and `gh pr checkout`)
git merge-base --fork-point master origin/branch_name
# note that 'git merge-base' returns no output once that branch has been merged to master.

# to find the oldest common ancestor (when multiple merges happen from one branch to another)
# https://stackoverflow.com/a/4991675/9201239
#  Given this find B
A - B - D - F - G   <- "master" branch (at G)
     \   \     /
      C - E --'     <- "topic" branch (still at E)
# replace topic with the branch name
     diff -u <(git rev-list --first-parent topic) \
             <(git rev-list --first-parent master) | \
     sed -ne 's/^ //p' | head -1
# if it's the current branch, it's just HEAD
     diff -u <(git rev-list --first-parent HEAD) \
             <(git rev-list --first-parent master) | \
     sed -ne 's/^ //p' | head -1
# same w/o sed:
diff --changed-group-format='' <(git rev-list --first-parent "${1:-master}") <(git rev-list --first-parent "${2:-HEAD}") | head -1
# and it doesn't always work either

# diff between the branching point and the HEAD of the branch
git diff $(git merge-base --fork-point master origin/branch_name)..origin/branch_name
# in the case of the currently checked out branch, it's just
git diff $(git merge-base --fork-point master HEAD)..HEAD

# get modified files between current state and the branching point (doesn't matter whether the
# files have been staged, pushed or locally modified). only requires that the files are under git.
def_branch=$(git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@'); git diff $(git merge-base $def_branch HEAD)
# or
git diff $(git merge-base $(git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@') HEAD)
# the old one no longer works on default branches that are 'main'
# git diff --name-only $(git merge-base master HEAD)
#
# handy aliases based on this
alias brdiff2="def_branch=\$(git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@'); git diff \$(git merge-base \$def_branch HEAD)"
alias bremacs2="def_branch=\$(git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@'); emacs \$(git diff --name-only \$(git merge-base \$def_branch HEAD)) &"
alias brfiles2="def_branch=\$(git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@'); git diff --name-only \$(git merge-base \$def_branch HEAD)"
#
# the problem is that they often include merged files from rebasing as well, so to get just the
# changes of this branch excluding any rebased main/master, we use:
# git diff --name-only origin/main... or git diff --name-only origin/master...
# which gives:
alias brdiff="def_branch=\$(git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@'); git diff origin/\$def_branch..."
alias bremacs="def_branch=\$(git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@'); emacs \$(git diff --name-only origin/\$def_branch...) &"
alias brfiles="def_branch=\$(git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@'); git diff --name-only origin/\$def_branch..."

# commits between the branching point and the HEAD of the branch
git log --oneline $(git merge-base --fork-point master origin/branch_name)..origin/branch_name
# for the currently checked out branch:
git log --oneline $(git merge-base --fork-point master HEAD)..HEAD

# find branches the commit is on
git branch --contains <commit>

# find when a commit was merged into one or more branches.
# https://github.com/mhagger/git-when-merged
git when-merged [OPTIONS] COMMIT [BRANCH...]

### branch tracking ###

# branch tracking is set in the local git checkout (not in the upsteam repo)
#
# e.g to set the tracking to master:
git push --set-upstream origin master
# or to a branch name
git push --set-upstream origin my-branch-name
#
# alternatively, the same done during a branch creation, note the 2
# args from above are combined into 1:
#
# e.g. set to track to master:
git branch -u origin/master
# or to a branch name
git branch -u origin/my-branch-name
#
# branch, check out and set upstream in a single command:
git checkout -b my-branch-name -t origin/my-branch-name

# show which locally checked out git branches are tracking which remote / upstream branch?
git branch -vv
# note: it will only show branches that were ever checked out locally
#
# add: --all to show remote branches too
#
# and first make to sure sync all the remote info on branches: git fetch --all
#
# similar but easier to parse in a script (paste directly into bash):
while read branch; do
  upstream=$(git rev-parse --abbrev-ref $branch@{upstream} 2>/dev/null)
  if [[ $? == 0 ]]; then
    echo $branch tracks $upstream
  else
    echo $branch has no upstream configured
  fi
done < <(git for-each-ref --format='%(refname:short)' refs/heads/*)


# some good docs on branching strategies:
https://nvie.com/posts/a-successful-git-branching-model/


############
### tags ###
############


### List tags

# all tags
git tag

# tags matching pattern
git tag -l "1.8.5*"

# by date
git log --tags --simplify-by-decoration --pretty="format%ci %d"

# last tag
git describe --abbrev=0 --tags

### Create tags

# To tag current checkout with tag "1.0.5" with current date
git tag -a test-1.0.5 -m "test-1.0.5"
git push --tags origin master

# To tag commit 9fceb02a with tag "1.0.5" with current date
git checkout 9fceb02a
git tag -a v1.0.5 -m "1.0.5"
git push --tags origin master
git checkout master

# To tag commit 9fceb02a with tag "1.0.5" with the date of that commit
git checkout 9fceb02a
GIT_COMMITTER_DATE="$(git show --format=%aD | head -1)" git tag -a v1.0.5 -m "1.0.5"
git push --tags origin master
git checkout master

# or the same without needing to `git checkout` and with typing the variables only once
tag="0.1.3" commit="9fceb02a" bash -c 'GIT_COMMITTER_DATE="$(git show --format=%aD $commit)" git tag -a $tag -m $tag $commit'
git push --tags origin master

# To find out the hash of the last commit in a branch, to use in back-tagging
git log -n 1 origin/release-1.0.25

### Push tags

# push both commits and only tags that are both:
# 1. annotated
# 2. reachable (an ancestor) from the pushed commits
git push --follow-tags

# this is not the best way, since it'll push all local tags
git push --tags

# push the tag explicitly (to avoid it being mixed with a branch of the same name)
git push origin tag "1.0.5"

### Delete tags

# Delete remote tag
# An unambiguous way
git push origin refs/tags/v1.0.5
# An ambiguous way (may delete a branch if it's named the same as the tag)
git push --delete origin v1.0.5

# Delete multiple tags
git push --delete origin tag1 tag2

# Delete local tag
git tag --delete v0.1.5
git push --tags origin master
# This is important since if the remote tag is deleted, but the local is not, then on the next `git push --tags origin master` it will get restored in remote.

# Useful scripts:
- [git-backtag](https://github.com/lucasrangit/git-bin/blob/master/git-backtag)



##################
### git bisect ###
##################

# git bisect helps to quickly find the commit that caused a certain problem

# 1. start
git bisect start

# 2. say which is the first known good commit, e.g.:
git bisect good 9851205ffc9cc3

# 3. say which is the first known bad commit (e.g. HEAD)
git bisect bad HEAD

# 4. next run a test to see whether the checkout is good or bad, and depending on the outcome the next command should be one of two:
git bisect good
git bisect bad

# keep going until the problem is found, and then stop the process with:
git bisect reset

# if for some reason the current version cannot be tested - it can be skipped and it will continue bisecting with the rest
git bisect skip

# if bad happens before good revision order-wise, and normally git expects bad to be after good, reverse the definition
git bisect start --term-new=fixed --term-old=broken
git bisect fixed master
git bisect broken 6c94774
# then use
git fixed / git broken

# show current range of remaining commits to check
git bisect visualize --oneline

#################
### git hooks ###
#################

###
### strip output from Jupyter and IPython notebooks ###
###

# install nbstripout
pip install nbstripout

# check it's in the path:
which nbstripout

# switch to the repository you want to work in
cd fastai_v1/



### automatic install for git commit and git diff
nbstripout --install


### manual git commit instrumentation

# add to .gitattributes or .git/info/attributes:
*.ipynb filter=nbstripout

# these will modify .git/config
git config filter.nbstripout.clean `which nbstripout`
git config filter.nbstripout.smudge cat
git config filter.nbstripout.required true

### manual git diff instrumentation

# add to .gitattributes or .git/info/attributes:
*.ipynb diff=ipynb

# this will modify .git/config
git config diff.ipynb.textconv "$(which nbstripout) -t"




### git filters

# - before check in: clean filter
# - before checkout: smudge filter

# to check what the "clean" filter produced (to see the actual contents of the index)
git show :0:repo-relative/path/to/file
# you can not usually use git diff for this since it also applies the filters.

# report all attributes set on file
git check-attr -a repo-relative/path/to/file

## useful git filters
# git keyword expansion.
https://github.com/gistya/expandr



### fixing things

# in a PR branch, after committing and pushing a bunch of bad commits (e.g. bad merge), undo it and
# move HEAD to the last good commit.
# definitely a no-no if others participate in the same branch
git reset --hard <last_good_commit>
git push --force



# after resolving the merge conflict
#   error: You have not concluded your merge (MERGE_HEAD exists).
git status
# 1. for every unmerged file (after you resolve conficts by yourself):
git add unmerged files
# 2. if there is no unmerged files:
git commit # without any file(s)

# might have to run this, if git status shows files in green, they shouldn't be staged (e.g. after `git stash apply` merge conflict)
git reset HEAD

# if move some files away during merge, you may end up with them being reported
# as unmerged and deleted, e.g.:
# error: path … is unmerged)
#        deleted:    nbs/dl1/lesson6-pets-more.ipynb
# git checkout .
# error: path 'nbs/dl1/lesson6-pets-more.ipynb' is unmerged
# so this repairs it (replace 'master' with the needed branch name)
git checkout origin/master .

# to fix a bad merge
https://stackoverflow.com/questions/307828/how-do-you-fix-a-bad-merge-and-replay-your-good-commits-onto-a-fixed-merge

# "fatal: Unknown index entry format 61740000".
# when your index is broken you can normally delete the index file and reset it.
rm -f .git/index
git reset
# or you clone the repo again.

# forked master branch should never be modified, or it'd break any rebasing - so if this happens and you get the error:
# failed to push some refs to 'git@github.com:stas00/transformers.git'
# "updates were rejected because the tip of your current branch is behind its remote counterpart"
# when forked master has been changed manually and isn't in sync with the upstream master
# we need to reset the forked master branch to be the same as upstream master branch:
git checkout master
git fetch upstream
git reset --hard upstream/master
git push --force

### merge strategies

# tell git not to merge certain files (i.e. keep the local version) by defining merge filter 'ours'.
# https://stackoverflow.com/a/5895890/9201239
# 1) add to .gitattributes:
database.xml merge=ours
# 2) set git merge driver to do nothing but return success
git config merge.ours.name '"always keep ours" merge driver'
git config merge.ours.driver 'touch %A'
# git config merge.ours.driver true


### trace and debug

# check which config comes from where
git config --list --show-origin

# display git attributes for a specific path
git check-attr -a dev_nb/001b_fit.ipynb

# more here:
# https://git-scm.com/book/en/v2/Git-Tools-Debugging-with-Git

# trace
GIT_TRACE=1 git pull origin master

# very verbose
set -x; GIT_TRACE=2 GIT_CURL_VERBOSE=2 GIT_TRACE_PERFORMANCE=2 GIT_TRACE_PACK_ACCESS=2 GIT_TRACE_PACKET=2 GIT_TRACE_PACKFILE=2 GIT_TRACE_SETUP=2 GIT_TRACE_SHALLOW=2 git pull origin master -v -v; set +x

# different options:
    GIT_TRACE for general traces,
    GIT_TRACE_PACK_ACCESS for tracing of packfile access,
    GIT_TRACE_PACKET for packet-level tracing for network operations,
    GIT_TRACE_PERFORMANCE for logging the performance data,
    GIT_TRACE_SETUP for information about discovering the repository and environment it’s interacting with,
    GIT_MERGE_VERBOSITY for debugging recursive merge strategy (values: 0-5),
    GIT_CURL_VERBOSE for logging all curl messages (equivalent to curl -v),
    GIT_TRACE_SHALLOW for debugging fetching/cloning of shallow repositories.

possible values can include:

    true, 1 or 2 to write to stderr,
    an absolute path starting with / to trace output to the specified file.


# debugging/tracing content filters

How to get git to show specific filenames it is running content filters on

GIT_TRACE should always show the arguments. But unless you specify arguments in the clean/smudge filter config, then Git won't pass any. The stdin/stdout stream is all that matters.

So e.g.:

  $ echo '* filter=foo' >.gitattributes
  $ git config filter.foo.clean 'myfilter'
  $ GIT_TRACE=1 git add .
  19:42:16.516401 [pid=14112] git.c:415             trace: built-in: git add .
  19:42:16.517454 [pid=14112] run-command.c:637     trace: run_command: myfilter

  $ git config filter.foo.clean 'myfilter --foo'
  $ touch .gitattributes ;# make sure we actually read it again ;)
  $ GIT_TRACE=1 git add .
  19:42:58.122942 [pid=14156] git.c:415             trace: built-in: git add .
  19:42:58.124023 [pid=14156] run-command.c:637     trace: run_command: 'myfilter \
--foo'

You can use "%f" to pass the name of the file, like:

  $ git config filter.foo.clean 'myfilter %f'
  $ touch .gitattributes
  $ GIT_TRACE=1 git add .
  19:44:51.187177 [pid=14318] git.c:415             trace: built-in: git add .
  19:44:51.188256 [pid=14318] run-command.c:637     trace: run_command: 'myfilter \
'\''.gitattributes'\'''

Of course that won't be helpful if your filter actually respects the argument. For a "clean" filter that might be OK (e.g., if it just tells your filter to read from the filesystem instead of stdin), but it's almost certainly not what you want for a "smudge" filter.

You can work around it with some shell hackery:

  git config filter.foo.clean 'f() { echo >&2 "cleaning $1"; myfilter ...; }; f %f'

and then even without GIT_TRACE, you get:

  $ git add .
  cleaning .gitattributes

Or if you really just want to trigger for GIT_TRACE, try just this:

  $ git config filter.foo.clean 'f() { myfilter; }; f %f'
  19:52:52.874064 [pid=14719] git.c:415             trace: built-in: git add .
  19:52:52.875115 [pid=14719] run-command.c:637     trace: run_command: 'f() { \
myfilter; }; f '\''.gitattributes'\'''

There you get the name in the trace output, but the invoked command does not actually do anything with it.

So I ended up using:

[filter "nbstripout"]
    clean  = "f() { echo >&2 \"clean: nbstripout $1\"; nbstripout; }; f %f"
    smudge = "f() { echo >&2 \"smudge: cat $1\"; cat; }; f %f"
    required = true

and now I get the filenames logged when run with GIT_TRACE=1, and without it.





### reverting/resetting/undoing

# lots of scenarios here:
https://blog.github.com/2015-06-08-how-to-undo-almost-anything-with-git/

# undo merge in progress before it was committed (e.g. when having CONFLICTS)
git merge --abort

# undo the last commit before it was pushed
git reset --soft HEAD~1
# for several commits change 1 to the number of commits

# or for all commits to be undone at once
git reset --soft origin/HEAD
# check `git log` to see where origin/HEAD points

# also side-effect is that `git diff` won't show the right diff anymore for those files that were
# reset, to see the diff use:
git diff origin/HEAD

# revert the last commit
git revert HEAD

# revert a specific commit
git revert <hash>

# revert everything from the HEAD back to the commit hash 0766c053
git revert --no-commit 0766c053..HEAD
git commit
# this will revert everything from the HEAD back to the commit hash, meaning it will recreate that commit state in the working tree as if every commit since had been walked back. You can then commit the current tree, and it will create a brand new commit essentially equivalent to the commit you "reverted" to.
# (the --no-commit flag lets git revert all the commits at once- otherwise you'll be prompted for a message for each commit in the range, littering your history with unnecessary new commits.)
# this is a safe and easy way to rollback to a previous state. No history is destroyed, so it can be used for commits that have already been made public.

# if merge happened earlier, revert could fail and ask for a specific parent branch via -m flag to specify which mainline to use
# for details: http://schacon.github.io/git/howto/revert-a-faulty-merge.txt
# and https://stackoverflow.com/questions/5970889/why-does-git-revert-complain-about-a-missing-m-option

# relative refs
^      - one commit at a time (parent of the specified commit)
master^  = the first parent of master
master^^ = the first grandparent of master
~<num> - several commits

# revert your repository to a specific revision
git checkout <rev>
# revert only parts of your repository to a specific revision
git checkout <rev> -- dir1 dir2 file1 file2
# revert to HEAD (default)
git checkout dir1 dir2 file1 file2
# it is probably a good idea to take a snapshot of the edits before overwriting them
# 1. via git stash (stash, unstash while keeping copy in the stash)
git stash push -m "co backup"; git stash apply
# [alias]
# co = !sh -c 'git stash push -m "co backup"; git stash apply; git checkout "$*"'
# 2. via patch
git diff > patchfile
# and restore (i.e. re-apply the patch) if need be:
# git apply patchfile
# or:
# patch -p1 < patchfile

# reset branch's HEAD to a given commit hash:
# find the last commit that was supposed to be the HEAD, e.g.:
# https://github.com/fastai/fastai/commit/1c63e868d3d11e73d9f51f58cbd271e67a0fe983
# and now reset the branch's HEAD to it
git checkout release-1.0.36
git reset --hard 1c63e868d3
git push --force origin release-1.0.36
#
# or can reset to number of commits back
git reset @~2 # reset to 2 commits back
# where N is the number of commits before HEAD (in @~N), and @~ resets to the previous commit.

### ignore

# to temporarily ignore changes in a certain file, run:
git update-index --assume-unchanged <file>
# track changes again:
git update-index --no-assume-unchanged <file>



### revisions

# ranges illustration
A ─┬─ E ── F ── G   master
   └─ B ── C ── D   fix
git log master..fix 	BCD
git log master...fix 	BCD and EFG

git log master 	      reachable parents from master
git log ^master 	  exclude reachable parents from master
git log master..fix   reachable from fix but not master
git log master...fix  reachable from fix and master, but not both
git log HEAD^@ 	      parents of HEAD
git log HEAD^! 	      HEAD, then excluding parents’s ancestors
git log HEAD^{:/fix}  search previous HEADs matching criteria



### cleanup and pruning

# over time the local checkout needs cleaning and optimizing,
git gc

# sometimes errors like these happen:
# - unable to resolve reference refs/remotes/origin/LT558-optimize-sql
# - cannot lock ref 'refs/remotes/origin/master': is at 284fd3e1c4d50931bc27f8d10c2f883d4848812d but expected da2bb09440c5ac47da5729153177a9817bdd5c43
# so something gets messed up in the local repo, fix it with:
git gc --prune=now
git remote prune origin

### overriding git configuration

git -c http.proxy=someproxy clone https://github.com/user/repo.git
git -c user.email=email@domain.fr -c user.name='Your Name'

# override git diff:
git diff --no-ext-diff
# no such option exists for merge drivers.

# switch remote URLs from HTTPS to SSH
git remote set-url origin git@github.com:USERNAME/REPOSITORY.git



### Workflows ###

# working and updating the local checkout with upstream changes https://stackoverflow.com/questions/457927/git-workflow-and-rebase-vs-merge-questions?rq=1
clone the remote repository
git checkout -b my_new_feature
..work and commit some stuff
git rebase master
..work and commit some stuff
git rebase master
..finish the feature, commit
git rebase master
git checkout master
git merge --squash my_new_feature
git commit -m "added my_new_feature"
git branch -D my_new_feature


### Github shortcuts ###

# to start a built in editor
press '.'

# to get permalink link to a file in a specific commit (e.g. the one being browsed in master)
press `y` - the location bar will rewrite itself with the commit sha in it.

# link to a range of lines - use #Lxxx-Lxxx
http://github.com/jquery/jquery/blob/27291ff06ddb655f90a8d1eada71f7ac61499b12/src/css.js#L171-L185.

## issue filters:

# search comments by me:
commenter:stas00


# show commits by range: master@{time}..master

You can create a compare view in GitHub by using the URL github.com/user/repo/compare/{range}. Range can be two SHAs like sha1…sha2 or two branches’ name like master…my-branch. Range is also smart enough to take time into consideration.

For example, you can filter a list of commits since yesterday by using format like master@{1.day.ago}…master. The link https://github.com/rails/rails/compare/master@{1.day.ago}…master, for example, gets all commits since yesterday for the Rails project:


# show commits by author: ?author=github_handle

You can filter commits by author in the commit view by appending param ?author=github_handle.

For example, the link https://github.com/dynjs/dynjs/commits/master?author=jingweno shows a list of my commits to the Dynjs project


# show .diff & .patch

Add .diff or .patch to the URLs of compare view, pull request or commit page to get the diff or patch in text format.

For example, the link https://github.com/rails/rails/compare/master@{1.day.ago}…master.patch gets the patch for all the commits since yesterday in the Rails project


# line linking

In any file view, when you click one line or multiple lines by pressing SHIFT, the URL will change to reflect your selections. This is very handy for sharing the link to a chunk of code with your teammates

# plugins
- GitHub toggle diff comments
https://github.com/Mottie/GitHub-userscripts/wiki/GitHub-toggle-diff-comments

### hub ###

Hub is the command line GitHub. It provides integration between Git and GitHub in command line. One of the most useful commands is creating pull request by just typing “hub pull-request” in your terminal. Detail of all other commands is available on its project readme.

###################
### large files ###
###################

git lfs
git-lfs

# run once:
git lfs install

# set to track a specific extension
git lfs track "*.gz"
git commit -m "compressed files" .gitattributes
git push

# now add the files normally
git add foo.tar.gz
git commit -m "foo.tar.gz" foo.tar.gz
git push

# to remove file from lfs and make it normal
git lfs untrack '<pattern>'
git add --renormalize .
git commit -m 'remove lfs pattern; Undo LFS for that pattern'

# force one lfs file download at a time if concurrent LFS file download is too much
# the default value is 8
git -c lfs.concurrenttransfers=1 clone https://huggingface.co/EleutherAI/gpt-j-6B
# or set it globally
git config --global lfs.concurrenttransfers 1



##############
### config ###
##############

# change default editor
# change config:
git config --global core.editor "nano"
# or set:
export GIT_EDITOR=vim

###############
### aliases ###
###############

# show git aliases
git config --get-regexp '^alias\.'
# or (with apt install git-extras)
git-alias

# best to add manually with editor, but can use CLI
.gitconfig
   [alias]
# e.g.
git config --global alias.co checkout


git config --global alias.br branch
git config --global alias.ci commit
git config --global alias.st status

# git unstage fileA
# equivalent of:
# git reset HEAD -- fileA
git config --global alias.unstage 'reset HEAD --'

# see last commit
git config --global alias.last 'log -1 HEAD'

# use ! for non-git sub-commands, e.g.:
git config --global alias.visual '!gitk'

# and even better ~/.bash_aliases, so requires no 'git ' prefix:
### git aliases ###
alias ga='git add'
alias gb='git branch'
alias gc='git commit'
alias gd='git diff'
alias gk='gitk --all&'
#alias go='git checkout '
alias gp='git push'
alias gs='git status'
alias gx='gitx --all'
alias git-cleanup='tools/trust-origin-git-config -d; git pull; tools/trust-origin-git-config'


#############
### forks ###
#############

To see others forking my project (e.g. perhaps to see if someone solved some problems in their fork) add /network after the git url, e.g.:

https://github.com/isaacs/github/network

and full list:

https://github.com/isaacs/github/network/members

#################
### workflows ###
#################

# delete all workflows that aren't master on stas00/transformers (Actions tab)

user=stas00 repo=transformers; gh api repos/$user/$repo/actions/runs | jq -r '.workflow_runs[] | select(.head_branch != "master") | "\(.id)"' | xargs -n1 -I % gh api repos/$user/$repo/actions/runs/% -X DELETE

# list workflows

user=stas00 repo=transformers; gh api -X GET /repos/$user/$repo/actions/workflows | jq '.workflows[] | .name,.id'

#################
### bash cmds ###
#################

# from username/reponame from the local clone, e.g. stas00/Megatron-DeepSpeed
repo_user_repo_name=$(git config --get remote.origin.url | sed 's|^.*//||; s/.*@//; s/[^:/]\+[:/]//; s/.git$//')



#######################
### bash-git-prompt ###
#######################

# turn it on/off in the current shell
git_prompt_toggle
